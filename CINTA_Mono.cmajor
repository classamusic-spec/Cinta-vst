/* ═══════════════════════════════════════════════════════════════
   CINTA MONO - Monophonic Single Engine Version
   Ultra-simplified to bypass Cmajor compiler bug
   ═══════════════════════════════════════════════════════════════ */

processor SimpleFM
{
    input event
    {
        std::notes::NoteOn noteOn;
        std::notes::NoteOff noteOff;
        float fm_ratio;
        float fm_depth;
        float fm_level;
        float amp_attack;
        float amp_decay;
        float amp_sustain;
        float amp_release;
        float master_volume;
    }
    
    output stream float<2> audioOut;
    
    event noteOn(std::notes::NoteOn e)
    {
        noteFreq = std::notes::noteToFrequency(e.pitch);
        velocity = e.velocity;
        noteActive = true;
        envPhase = 0;
    }
    
    event noteOff(std::notes::NoteOff e)
    {
        noteActive = false;
    }
    
    event fm_ratio(float v) { ratio = v; }
    event fm_depth(float v) { depth = v; }
    event fm_level(float v) { level = v; }
    event amp_attack(float v) { attack = v; }
    event amp_decay(float v) { decay = v; }
    event amp_sustain(float v) { sustain = v; }
    event amp_release(float v) { release = v; }
    event master_volume(float v) { masterVol = v; }
    
    float noteFreq = 440.0f;
    float velocity = 0.8f;
    bool noteActive = false;
    float phase = 0.0f;
    float modPhase = 0.0f;
    int envPhase = 0;
    float envLevel = 0.0f;
    
    float ratio = 2.0f;
    float depth = 0.5f;
    float level = 0.8f;
    float attack = 0.01f;
    float decay = 0.1f;
    float sustain = 0.7f;
    float release = 0.3f;
    float masterVol = 0.8f;
    
    void main()
    {
        let sampleRate = float(processor.frequency);
        let phaseInc = noteFreq / sampleRate;
        let modPhaseInc = (noteFreq * ratio) / sampleRate;
        
        loop
        {
            // Envelope
            if (noteActive)
            {
                if (envPhase == 0)
                {
                    envLevel += 1.0f / (attack * sampleRate);
                    if (envLevel >= 1.0f)
                    {
                        envLevel = 1.0f;
                        envPhase = 1;
                    }
                }
                else if (envPhase == 1)
                {
                    envLevel -= (1.0f - sustain) / (decay * sampleRate);
                    if (envLevel <= sustain)
                    {
                        envLevel = sustain;
                        envPhase = 2;
                    }
                }
            }
            else
            {
                envLevel -= sustain / (release * sampleRate);
                if (envLevel < 0.0f)
                    envLevel = 0.0f;
            }
            
            // FM Synthesis
            let modulator = float(sin(modPhase * twoPi)) * depth;
            let carrier = float(sin((phase + modulator) * twoPi));
            let signal = carrier * envLevel * level * velocity * masterVol * 0.5f;
            
            phase += phaseInc;
            modPhase += modPhaseInc;
            
            if (phase >= 1.0f) phase -= 1.0f;
            if (modPhase >= 1.0f) modPhase -= 1.0f;
            
            audioOut <- float<2>(signal, signal);
            advance();
        }
    }
}

graph CINTA_Mono [[ main ]]
{
    input event
    {
        std::notes::NoteOn noteOn;
        std::notes::NoteOff noteOff;
        float fm_ratio;
        float fm_depth;
        float fm_level;
        float amp_attack;
        float amp_decay;
        float amp_sustain;
        float amp_release;
        float master_volume;
    }
    
    output stream float<2> audioOut;
    
    node synth = SimpleFM;
    
    connection
    {
        noteOn -> synth.noteOn;
        noteOff -> synth.noteOff;
        fm_ratio -> synth.fm_ratio;
        fm_depth -> synth.fm_depth;
        fm_level -> synth.fm_level;
        amp_attack -> synth.amp_attack;
        amp_decay -> synth.amp_decay;
        amp_sustain -> synth.amp_sustain;
        amp_release -> synth.amp_release;
        master_volume -> synth.master_volume;
        
        synth.audioOut -> audioOut;
    }
}
